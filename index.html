<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
input[type="range"].horizontal {
  width: 400px
}
</style>
</head>
<body>
  <section id="plotArea">
    <table>
    <tr><td>Maximum iterations</td>
        <td><input class="horizontal" id="max_iters" type="range" min="100" max="10000" step="50" value="1000"></td>
        <td><span id="max_iters_txt"></span></td></tr>
    <tr><td>Zoom</td>
        <td><input class="horizontal" id="zoom" type="range" min="100" max="10000" step="50" value="200"></td>
        <td><span id="zoom_txt"></span></td></tr>
    <tr><td>X origin</td>
      <td><input class="horizontal" id="origin_x" type="range" min="-2" max="2" step="0.01" value="-0.5"></td>
      <td><span id="origin_x_txt"></span></td></tr>
    <tr><td>Y origin</td>
        <td><input class="horizontal" id="origin_y" type="range" min="-2" max="2" step="0.01" value="0"></td>
        <td><span id="origin_y_txt"></span></td></tr>
    <tr><td><input id="reset_ui_button" type="button" value="Reset all sliders"></td></tr>
    <tr><td colspan="3">Mouse position over Mandelbrot canvas (<span id="x_canvas_pos"></span>,<span id="y_canvas_pos"></span>)</td></tr>
    <tr><td colspan="3">Mandelbrot set calculation time <span id="mandel_exec_time"></span> ms</td></tr>
    <tr><td colspan="3">
            <canvas id="mandelImage" style="border: 1px solid black"></canvas></td>
    <tr><td colspan="3">Julia set corresponding to coordinates (<span id="x_complex_coord"></span>,<span id="y_complex_coord"></span>) on the Mandelbrot set</td></tr>
    <tr><td colspan="3">Julia set calculated in <span id="julia_exec_time"></span>ms</td></tr>
    <tr><td colspan="3">
      <canvas id="juliaImage"  style="border: 1px solid black"></canvas></td></tr>
    </table>
  </section>
<script type="module">
// import {
//   showHostFns,
//   testWasm,
// } from "./src/js/testUtils.js"

import {
  WasmModule,
  instantiateWasmModuleSequence
} from "./src/js/wasmUtils.js"

// import { complexTestMap } from "./src/complex/tests.js"
// import { mandelTestMap }  from "./src/mandel/tests.js"
// import { colourTestMap }  from "./src/render/tests.js"

// const TEST_MODE   = false
// const SHOW_DETAIL = false

const WASM_PAGE_SIZE = 1024 * 64

const DEFAULT_CANVAS_WIDTH  = 800
const DEFAULT_CANVAS_HEIGHT = 450
const DEFAULT_PPU           = 200              // Default pixels per unit (controls zoom level)
const DEFAULT_ORIGIN_STEP   = 0.01             // Slider step interval when the origin is moved
const DEFAULT_ORIGIN_X      = -0.5             // Centre X canvas pixel in the Mandelbrot coordinate space
const DEFAULT_ORIGIN_Y      = 0                // Centre Y canvas pixel in the Mandelbort coordinate space
const DEFAULT_MAX_ITERS     = 150              // Default number of iterations for the escape time algorithm

const toMilliTenths = val => Math.round(val * 10000) / 10000
function $id(el) { return document.getElementById(el) }

// ---------------------------------------------------------------------------------------------------------------------
// Mouse handler functions

// Translate the mouse X or Y canvas position to the corresponding X or Y coordinate in the complex plain
const canvas_pxl_to_coord = (cnvsDim, ppu, origin) => mousePos => origin + ((mousePos - (cnvsDim / 2)) / ppu)

// Return a value clamped to the magnitude of the canvas image dimension that accountd for the canvas border width
const offset_to_clamped_pos = (offset, dim, offsetDim) => {
  let pos = offset - ((offsetDim - dim) / 2)
  return pos < 0 ? 0 : pos > dim ? dim : pos
}

// Track mouse pointer position in the Mandelbrot set
const mouse_track = evt => {
  let ox = $id("origin_x").value * 1
  let oy = $id("origin_y").value * 1

  let x_pxl = offset_to_clamped_pos(evt.offsetX, evt.target.width,  evt.target.offsetWidth)
  let y_pxl = offset_to_clamped_pos(evt.offsetY, evt.target.height, evt.target.offsetHeight)

  $id('x_canvas_pos').innerHTML = x_pxl
  $id('y_canvas_pos').innerHTML = y_pxl
  $id('x_complex_coord').innerHTML = window.mandel_x_pos_to_coord(x_pxl)
  $id('y_complex_coord').innerHTML = window.mandel_y_pos_to_coord(y_pxl) * -1

  if (drag_active) {
    $id("origin_x").value = ox - evt.movementX * DEFAULT_ORIGIN_STEP
    $id("origin_y").value = oy - evt.movementY * DEFAULT_ORIGIN_STEP

    update_img(evt)
  } else {
    julia.origin_x = ox
    julia.origin_y = oy
    julia.mandel_x = x_pxl
    julia.mandel_y = y_pxl
    julia.zoom     = $id("zoom").value

    draw_fractal(julia)
  }
}

// Mouse up and down events within the Mandelbrot set
const mouse_down = _ => drag_active = true
const mouse_up   = _ => drag_active = false

// ---------------------------------------------------------------------------------------------------------------------
function Fractal(name, canvas, context, image, imgStart, imgEnd) {
  this.name     = name
  this.canvas   = canvas
  this.context  = context
  this.image    = image
  this.imgStart = imgStart
  this.imgEnd   = imgEnd

  this.origin_x = DEFAULT_ORIGIN_X
  this.origin_y = DEFAULT_ORIGIN_Y
  this.mandel_x = 0
  this.mandel_y = 0
  this.zoom     = DEFAULT_PPU
}

// ---------------------------------------------------------------------------------------------------------------------
// Canvas definition
const mCanvas  = $id('mandelImage')
mCanvas.width  = DEFAULT_CANVAS_WIDTH
mCanvas.height = DEFAULT_CANVAS_HEIGHT

mCanvas.addEventListener('mousemove', mouse_track, false)
mCanvas.addEventListener('mousedown', mouse_down, false)
mCanvas.addEventListener('mouseup',   mouse_up, false)

const mContext    = mCanvas.getContext('2d')
const mImage      = mContext.createImageData(mCanvas.width, mCanvas.height)
const mImageSize  = mCanvas.width * mCanvas.height * 4
const mImagePages = Math.ceil(mImageSize / WASM_PAGE_SIZE)
const mImageStart = 0
const mImageEnd   = mImageSize
const mandelbrot  = new Fractal("mandel", mCanvas, mContext, mImage, mImageStart, mImageEnd)

const jCanvas  = $id('juliaImage')
jCanvas.width  = DEFAULT_CANVAS_WIDTH
jCanvas.height = DEFAULT_CANVAS_HEIGHT

const jContext    = jCanvas.getContext('2d')
const jImage      = jContext.createImageData(jCanvas.width, jCanvas.height)
const jImageSize  = jCanvas.width * jCanvas.height * 4
const jImagePages = Math.ceil(jImageSize / WASM_PAGE_SIZE)
const jImageStart = mImagePages * WASM_PAGE_SIZE
const jImageEnd   = jImageStart + jImageSize
const julia       = new Fractal("julia", jCanvas, jContext, jImage, jImageStart, jImageEnd)

// ---------------------------------------------------------------------------------------------------------------------
// WASM memory allocation
// Arbitrarily allocate 4 pages for the colour palette.
// This allows for enough colours for an image to be calculated with a maximum iteration value of 32768
const palettePages = 4

const wasmMemory  = new WebAssembly.Memory({ initial : mImagePages + jImagePages + palettePages })
const wasmMemBuff = new Uint8ClampedArray(wasmMemory.buffer)

const import_object = {
  math : Math,
  js : {
    shared_mem        : wasmMemory,
    mandel_img_offset : 0,
    julia_img_offset  : WASM_PAGE_SIZE * mImagePages,
    palette_offset    : WASM_PAGE_SIZE * (mImagePages + jImagePages),
  }
}

// ---------------------------------------------------------------------------------------------------------------------
// Manage sliders
let drag_active = false

let sliders = {
  'zoom' :      { currentValue : DEFAULT_PPU,       defaultValue : DEFAULT_PPU,       asInt : true },
  'max_iters' : { currentValue : DEFAULT_MAX_ITERS, defaultValue : DEFAULT_MAX_ITERS, asInt : true },
  'origin_x' :  { currentValue : DEFAULT_ORIGIN_X,  defaultValue : DEFAULT_ORIGIN_X,  asInt : false },
  'origin_y' :  { currentValue : DEFAULT_ORIGIN_Y,  defaultValue : DEFAULT_ORIGIN_Y,  asInt : false },
}

const reset_slider = sId => {
  let slider_obj = sliders[sId]
  let ui_slider = $id(sId)

  ui_slider.addEventListener("input", update_img, false)
  ui_slider.value = slider_obj.defaultValue

  slider_obj.currentValue = slider_obj.defaultValue
  $id(`${sId}_txt`).innerHTML = slider_obj.defaultValue

  return slider_obj
}

const update_slider = sId => {
  let slider_obj = sliders[sId]

  slider_obj.currentValue = slider_obj.asInt ? parseInt($id(sId).value) : parseFloat($id(sId).value)
  $id(`${sId}_txt`).innerHTML = slider_obj.currentValue

  return slider_obj
}

// ---------------------------------------------------------------------------------------------------------------------
const draw_fractal = f => {
  let then = window.performance.now()

  switch(f.name) {
    case "mandel":
      window.mandel_plot(f.canvas.width, f.canvas.height, f.origin_x, f.origin_y, f.zoom, sliders.max_iters.currentValue)
      break
    case "julia":
      window.julia_plot(f.canvas.width, f.canvas.height, f.origin_x, f.origin_y, f.mandel_x, f.mandel_y, f.zoom, sliders.max_iters.currentValue)

    default:
  }

  $id(`${f.name}_exec_time`).innerHTML = `${toMilliTenths(window.performance.now() - then)}`

  f.image.data.set(wasmMemBuff.slice(f.imgStart, f.imgEnd))
  f.context.putImageData(f.image,0,0)
}

// ---------------------------------------------------------------------------------------------------------------------
const update_img = evt => {
  sliders = Object
    .keys(sliders)
    .reduce((acc, sId) => { acc[sId] = update_slider(sId); return acc }, {})

  mandelbrot.origin_x = sliders.origin_x.currentValue
  mandelbrot.origin_y = sliders.origin_y.currentValue
  mandelbrot.zoom     = sliders.zoom.currentValue

  switch(evt.target.id) {
    case "max_iters":
      // Update the colour palette
      window.hsl_to_rgb(sliders.max_iters.currentValue)
      break

    // Update the pixel to coordinate translation functions
    case "zoom":
    case "origin_x":
    case "origin_y":
    case "mandelImage":
      window.mandel_x_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.width,  sliders.zoom.currentValue, mandelbrot.origin_x)
      window.mandel_y_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.height, sliders.zoom.currentValue, mandelbrot.origin_y)
      break

    default:
  }

  draw_fractal(mandelbrot)
}

const resetUI = () => {
  window.mandel_x_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.width,  DEFAULT_PPU, DEFAULT_ORIGIN_X)
  window.mandel_y_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.height, DEFAULT_PPU, DEFAULT_ORIGIN_Y)

  sliders = Object.keys(sliders).reduce((acc, sId) => { acc[sId] = reset_slider(sId); return acc }, {})

  // Generate default colour palette
  window.hsl_to_rgb(DEFAULT_MAX_ITERS)

  mandelbrot.origin_x = DEFAULT_ORIGIN_X
  mandelbrot.origin_y = DEFAULT_ORIGIN_Y
  mandelbrot.zoom     = DEFAULT_PPU

  draw_fractal(mandelbrot)
}

// ---------------------------------------------------------------------------------------------------------------------
// These WASM modules must be instantiated in the order listed below due to the fact that later modules have import
// dependencies on earlier modules
const instantiationSequence = [
  // new WasmModule('./build/complex.wasm',       'cplx'),
  new WasmModule('./build/mandel.wasm',         'mandel'),
  new WasmModule('./build/colour_palette.wasm', 'colours'),
  new WasmModule('./build/canvas.wasm',         'canvas'),
]

instantiateWasmModuleSequence(instantiationSequence, import_object)
  .then(wasmModules => {
    // testWasm(TEST_MODE, wasmModules.cplx.instance, complexTestMap, SHOW_DETAIL)
    // testWasm(TEST_MODE, wasmModules.mandel.instance, mandelTestMap, SHOW_DETAIL)
    // testWasm(TEST_MODE, wasmModules.canvas.instance, colourTestMap, SHOW_DETAIL)
    // showHostFns(wasmModules.hostFunctions)

    window.mandel_plot = wasmModules.canvas.instance.exports.mandel_plot
    window.julia_plot  = wasmModules.canvas.instance.exports.julia_plot
    window.hsl_to_rgb  = wasmModules.colours.instance.exports.hsl_to_rgb

    $id("reset_ui_button").addEventListener("click", resetUI, false)

    $id("origin_x").step = DEFAULT_ORIGIN_STEP
    $id("origin_y").step = DEFAULT_ORIGIN_STEP

    resetUI()
  })
</script>
</body>
</html>
