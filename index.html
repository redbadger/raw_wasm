<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Plotting Fractals Using WebAssembly Threads and Web Workers</title>
<link rel="stylesheet" href="./assets/style.css"charset="utf8">
</head>
<body>
  <table>
  <tr><td><a href="https://red-badger.com" target="_new"><img class="rb_logo" src="./assets/red-badger.svg"/></a></td>
      <td style="text-align: right;">
          <a href="https://github.com/redbadger/raw_wasm" target="_new">Git Repository</a></td></tr>
  <tr><td colspan="3">
      <h1 class="heading">Plotting Fractals Using WebAssembly Threads and Web Workers</h1></td></tr>
  <tr><td colspan="3">
        <table>
        <tr><td>Web Workers</td>
            <td><input class="horizontal" id="workers" type="range" min="1" max="12" step="1"></td>
            <td><span id="workers_txt"></span></td></tr>
        <tr><td>Maximum iterations</td>
            <td><input class="horizontal" id="max_iters" type="range"></td>
            <td><span id="max_iters_txt"></span></td></tr>
        <tr><td>Zoom</td>
            <td><input class="horizontal" id="zoom" type="range"></td>
            <td><span id="zoom_txt"></span></td></tr>
        <tr><td colspan="3" style="text-align: center;"><input id="reset_ui_button" type="button" value="Reset image"></td></tr>
        </table></td></tr>
  <tr><td colspan="3">Mandelbrot set calculation time <span id="mandel_exec_time"></span> ms</td></tr>
  <tr><td colspan="3">Drag to move image</td></tr>
  <tr><td colspan="2"><canvas id="mandelImage" style="border: 1px solid black"></canvas></td>
      <td style="vertical-align: text-top;">
          <table class="perf" border="0">
          <tr><td class="narrow visible"id="w0_cell1">W0:</td><td><span id="w0"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w1_cell1">W1:</td><td id="w1_cell2"><span id="w1"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w2_cell1">W2:</td><td id="w2_cell2"><span id="w2"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w3_cell1">W3:</td><td id="w3_cell2"><span id="w3"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w4_cell1">W4:</td><td id="w4_cell2"><span id="w4"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w5_cell1">W5:</td><td id="w5_cell2"><span id="w5"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w6_cell1">W6:</td><td id="w6_cell2"><span id="w6"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w7_cell1">W7:</td><td id="w7_cell2"><span id="w7"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w8_cell1">W8:</td><td id="w8_cell2"><span id="w8"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w9_cell1">W9:</td><td id="w9_cell2"><span id="w9"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w10_cell1">W10:</td><td id="w10_cell2"><span id="w10"></span> ms</td></tr>
          <tr><td class="narrow hidden" id="w11_cell1">W11:</td><td id="w11_cell2"><span id="w11"></span> ms</td></tr>
          </table></td></tr>
  <tr><td colspan="3">Julia set corresponding to (<span id="x_complex_coord"></span>,
          <span id="y_complex_coord"></span>) on the Mandelbrot set</td></tr>
  <tr><td colspan="3">Julia set calculated in <span id="julia_exec_time"></span> ms</td></tr>
  <tr><td colspan="2">
    <canvas id="juliaImage" style="border: 1px solid black"></canvas></td></tr>
  </table>
<script type="module">
function $id(el) { return document.getElementById(el) }

const microPrecision = val => Math.round(val * 10000) / 10000
const interval       = time => microPrecision(time.end - time.start)

/* ---------------------------------------------------------------------------------------------------------------------
 * Defaults and constants
 */
const GREEN = '#00CC66'

const WASM_PAGE_SIZE = 1024 * 64

// Range slider parameters
const RANGE_WORKERS   = { MIN : 1,   MAX : 12,    STEP : 1,  DEFAULT : 4 }
const RANGE_MAX_ITERS = { MIN : 100, MAX : 10000, STEP : 50, DEFAULT : 150 }
const RANGE_ZOOM      = { MIN : 100, MAX : 20000, STEP : 50, DEFAULT : 200 }

const DEFAULT_CANVAS_WIDTH  = 800
const DEFAULT_CANVAS_HEIGHT = 450

const DEFAULT_ORIGIN_STEP = 0.01               // Step size for dragging the Mandelbrot Set
const DEFAULT_ORIGIN_X    = -0.5               // Centre X canvas pixel in the Mandelbrot coordinate space
const DEFAULT_ORIGIN_Y    = 0                  // Centre Y canvas pixel in the Mandelbort coordinate space

/* ---------------------------------------------------------------------------------------------------------------------
 * For the fractal calculation to be distributed between worker threads, the index of the pixel being calculated must be
 * accessible to each thread via shared memory.  Each worker then accesses and modifies this value atomically
 *
 * Offset 0 = i32 holding current Mandelbrot pixel index
 * Offset 4 = i32 holding current Julia pixel index
 */
const COUNTERS_LEN = 8

/* ---------------------------------------------------------------------------------------------------------------------
 * Mouse handler functions
 */
let drag_active = false

/*
 * Mouse up/down events within the Mandelbrot set
 */
const mouse_down = _ => drag_active = true
const mouse_up   = _ => drag_active = false

/*
 * Partial function to translate the mouse X or Y canvas position to the corresponding X or Y coordinate in the complex
 * plane.  The `cnvsDim` never changes, and the `ppu` and `origin` values change only when the Mandelbrot Set is moved
 * or zoomed
 */
const canvas_pxl_to_coord = (cnvsDim, ppu, origin) => mousePos => origin + ((mousePos - (cnvsDim / 2)) / ppu)

/*
 * Return a value clamped to the magnitude of the canvas image dimension accounting also for the canvas border width
 */
const offset_to_clamped_pos = (offset, dim, offsetDim) => {
  let pos = offset - ((offsetDim - dim) / 2)
  return pos < 0 ? 0 : pos > dim ? dim : pos
}

/*
 * Track the mouse pointer position over the Mandelbrot set
 */
const mouse_track = evt => {
  let x_pxl = offset_to_clamped_pos(evt.offsetX, evt.target.width,  evt.target.offsetWidth)
  let y_pxl = offset_to_clamped_pos(evt.offsetY, evt.target.height, evt.target.offsetHeight)

  img_params.mandel_x.currentValue = x_pxl
  img_params.mandel_y.currentValue = y_pxl

  $id('x_complex_coord').innerHTML = window.mandel_x_pos_to_coord(x_pxl)
  $id('y_complex_coord').innerHTML = window.mandel_y_pos_to_coord(y_pxl) * -1

  if (drag_active) {
    let movement_factor = img_params.zoom.defaultValue / img_params.zoom.currentValue
    img_params.origin_x.currentValue -= evt.movementX * DEFAULT_ORIGIN_STEP * movement_factor
    img_params.origin_y.currentValue -= evt.movementY * DEFAULT_ORIGIN_STEP * movement_factor

    update_img(evt)
  } else {
    draw_fractal('julia')
  }
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Define canvas properties
 */
const mCanvas  = $id('mandelImage')
mCanvas.width  = DEFAULT_CANVAS_WIDTH
mCanvas.height = DEFAULT_CANVAS_HEIGHT

mCanvas.addEventListener('mousemove', mouse_track, false)
mCanvas.addEventListener('mousedown', mouse_down, false)
mCanvas.addEventListener('mouseup',   mouse_up, false)
mCanvas.addEventListener('mouseout',  mouse_up, false)

const mContext    = mCanvas.getContext('2d')
const mImage      = mContext.createImageData(mCanvas.width, mCanvas.height)
const mImageSize  = mCanvas.width * mCanvas.height * 4
const mImagePages = Math.ceil(mImageSize / WASM_PAGE_SIZE)
const mImageStart = COUNTERS_LEN
const mImageEnd   = mImageStart + mImageSize

const jCanvas  = $id('juliaImage')
jCanvas.width  = DEFAULT_CANVAS_WIDTH
jCanvas.height = DEFAULT_CANVAS_HEIGHT

const jContext    = jCanvas.getContext('2d')
const jImage      = jContext.createImageData(jCanvas.width, jCanvas.height)
const jImageSize  = jCanvas.width * jCanvas.height * 4
const jImagePages = Math.ceil(jImageSize / WASM_PAGE_SIZE)
const jImageStart = mImagePages * WASM_PAGE_SIZE
const jImageEnd   = jImageStart + jImageSize

/* ---------------------------------------------------------------------------------------------------------------------
* Allocate WASM memory
* 4 pages for the colour palette allows enough colours for an image calculated to an iteration depth of 32768
*/
const palettePages = 4

console.log('Required WASM memory pages')
console.log(`mImage = ${mImagePages}`)
console.log(`jImage = ${jImagePages}`)
console.log(`Colour palette = ${palettePages}`)

const wasmMemory = (totalMemPages => new WebAssembly.Memory({
  initial : totalMemPages,
  maximum : totalMemPages,
  shared : true,
}))(mImagePages + jImagePages + palettePages)

const wasmMemBuff = new Uint8ClampedArray(wasmMemory.buffer)

/* ---------------------------------------------------------------------------------------------------------------------
 * Initial and current states of Mandelbrot image
 */
let img_params = {
  'workers' : {
    currentValue : RANGE_WORKERS.DEFAULT,
    defaultValue : RANGE_WORKERS.DEFAULT,
    hasSlider : true
  },
  'zoom' : {
    currentValue : RANGE_ZOOM.DEFAULT,
    defaultValue : RANGE_ZOOM.DEFAULT,
    hasSlider : true
  },
  'max_iters' : {
    currentValue : RANGE_MAX_ITERS.DEFAULT,
    defaultValue : RANGE_MAX_ITERS.DEFAULT,
    hasSlider : true
  },
  'origin_x' :  { currentValue : DEFAULT_ORIGIN_X,  defaultValue : DEFAULT_ORIGIN_X,  hasSlider : false },
  'origin_y' :  { currentValue : DEFAULT_ORIGIN_Y,  defaultValue : DEFAULT_ORIGIN_Y,  hasSlider : false },
  'mandel_x' :  { currentValue : 0,                 defaultValue : 0,                 hasSlider : false },
  'mandel_y' :  { currentValue : 0,                 defaultValue : 0,                 hasSlider : false },
}

/*
 * Functions mapped over the img_params object
 */
const reset_img_params = sId => {
  let param_obj = img_params[sId]

  param_obj.currentValue = param_obj.defaultValue

  // Reset slider value
  if (param_obj.hasSlider) {
    $id(sId).value = param_obj.defaultValue
    $id(`${sId}_txt`).innerHTML = param_obj.defaultValue
  }

  return param_obj
}

// Mapped over img_params
const update_img_params = sId => {
  let param_obj = img_params[sId]

  // Store slider value
  if (param_obj.hasSlider) {
    param_obj.currentValue = parseInt($id(sId).value)
    $id(`${sId}_txt`).innerHTML = param_obj.currentValue
  }

  return param_obj
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Generate a worker message object
 */
const gen_worker_msg =
  (p_action, p_worker_id, p_fractal, p_host_fns) => {
    let response = {
      action : p_action,
      payload : {
        host_fns : {},
        fractal : {
          name     : p_fractal,
          width    : DEFAULT_CANVAS_WIDTH,
          height   : DEFAULT_CANVAS_HEIGHT,
          zoom     : img_params.zoom.currentValue,
          origin_x : img_params.origin_x.currentValue,
          origin_y : img_params.origin_y.currentValue,
          mandel_x : img_params.mandel_x.currentValue,
          mandel_y : img_params.mandel_y.currentValue,
        },
        max_iters : img_params.max_iters.currentValue,
        worker_id : p_worker_id,
      },
    }

    if (p_host_fns) response.payload.host_fns = p_host_fns

    return response
  }

let plot_time = { start : 0, end : 0, wCount : 0, isActive : false }

/* ---------------------------------------------------------------------------------------------------------------------
 * Draw the selected fractal
 */
const draw_fractal = f => {
  // Do not start a new plot if one is already running
  if (!plot_time.isActive) {
    plot_time.wCount   = 0
    plot_time.isActive = true
    plot_time.start    = window.performance.now()

    // Invoke all the workers
    window.worker_list.map((w, idx) => {
      $id(`w${idx}_cell1`).style.backgroundColor = GREEN
      w.postMessage(gen_worker_msg('exec', idx, f))
    })
  }
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Update the Mandelbrot Set image as it is dragged or zoomed
 */
const update_img = evt => {
  img_params = Object.keys(img_params).reduce((acc, sId) => { acc[sId] = update_img_params(sId); return acc }, {})

  switch(evt.target.id) {
    // Rebuild the colour palette
    case "max_iters":
      // Colour palette calculation is performed only by worker 0
      window.worker_list[0].postMessage(gen_worker_msg('refresh_colour_palette', 0))

      draw_fractal('julia')
      break

    // Whenever the origin moves, the pixel-to-coordinate translation functions must be updated
    case "zoom":
    case "origin_x":
    case "origin_y":
    case "mandelImage":
      window.mandel_x_pos_to_coord = canvas_pxl_to_coord(
        DEFAULT_CANVAS_WIDTH,
        img_params.zoom.currentValue,
        img_params.origin_x.currentValue
      )
      window.mandel_y_pos_to_coord = canvas_pxl_to_coord(
        DEFAULT_CANVAS_HEIGHT,
        img_params.zoom.currentValue,
        img_params.origin_y.currentValue
      )
      break

    default:
  }

  draw_fractal('mandel')
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Initial starting point for UI
 */
 const resetUI = (evt, isInitial) => {
  window.mandel_x_pos_to_coord = canvas_pxl_to_coord(DEFAULT_CANVAS_WIDTH,  RANGE_ZOOM.DEFAULT, DEFAULT_ORIGIN_X)
  window.mandel_y_pos_to_coord = canvas_pxl_to_coord(DEFAULT_CANVAS_HEIGHT, RANGE_ZOOM.DEFAULT, DEFAULT_ORIGIN_Y)

  img_params = Object.keys(img_params).reduce((acc, sId) => { acc[sId] = reset_img_params(sId); return acc }, {})

  rebuild_workers()

  if (!isInitial) draw_fractal('mandel')
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Worker thread message handler
 */
const worker_msg_handler =
  ({ data }) => {
    const { status, payload } = data
    const { worker_id, fractal, times } = payload

    switch(status) {
      // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      // Worker execution complete
      // payload = { worker_id, fractal, times }
      case 'exec_complete':
        plot_time.wCount += 1

        // Update this worker's performance time
        $id(`w${worker_id}_cell1`).style.backgroundColor = 'white'
        $id(`w${worker_id}`).innerHTML = interval(times.exec)

        // Have all the workers finished yet?
        if (plot_time.wCount === img_params.workers.currentValue) {
          plot_time.end = performance.now()

          $id(`${fractal}_exec_time`).innerHTML = interval(plot_time)

          switch(fractal) {
            case "mandel":
              mImage.data.set(wasmMemBuff.slice(mImageStart, mImageEnd))
              mContext.putImageData(mImage,0,0)
              break

            case "julia":
              jImage.data.set(wasmMemBuff.slice(jImageStart, jImageEnd))
              jContext.putImageData(jImage,0,0)
              break

            default:
          }

          // Reset X,Y iteration counters in shared memory
          for (let i=0; i<COUNTERS_LEN; i++) {
            wasmMemBuff[i] = 0x0
          }

          plot_time.wCount   = 0
          plot_time.isActive = false
        }

      default:
    }
  }

/*
 * Any values of functions imported by WASM from the host environment go here
 */
 const host_fns = {
  js : {
    shared_mem        : wasmMemory,
    mandel_img_offset : COUNTERS_LEN,
    julia_img_offset  : WASM_PAGE_SIZE * mImagePages,
    palette_offset    : WASM_PAGE_SIZE * (mImagePages + jImagePages),
  }
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Build required number of worker threads
 */
const rebuild_workers = () => {
  img_params = Object
    .keys(img_params)
    .reduce((acc, sId) => { acc[sId] = update_img_params(sId); return acc }, {})

  if (window.worker_list === undefined) window.worker_list = new Array()

  // If the existing worker_list is empty or the number of workers has changed, terminate any existing workers before
  // then create new ones
  if (window.worker_list.length === 0 ||
      (window.worker_list.length > 0 &&
       window.worker_list.length !== img_params.workers.currentValue)) {
    // Terminate any workers that might currently be active
    window.worker_list.map(w => w.terminate() )
    window.worker_list = new Array()

    plot_time.start = window.performance.now()

    // Create new set of workers
    for (let i=0; i<img_params.workers.currentValue; i++) {
      // Worker 0 is always visible
      if (i>0) {
        $id(`w${i}_cell1`).classList.remove("hidden")
        $id(`w${i}_cell2`).classList.remove("hidden")
        $id(`w${i}_cell1`).classList.add("visible")
        $id(`w${i}_cell2`).classList.add("visible")
      }

      let w = new Worker('src/js/worker.js')
      window.worker_list.push(w)

      // Respond to messages sent from the worker
      w.onmessage = worker_msg_handler

      // Start worker and draw initial Mandelbrot Set
      $id(`w${i}_cell1`).style.backgroundColor = GREEN
      w.postMessage(gen_worker_msg('init', i, 'mandel', host_fns))
    }

    // Switch off unused worker performance fields
    for (let i=img_params.workers.currentValue; i<RANGE_WORKERS.MAX; i++) {
      $id(`w${i}_cell1`).classList.remove("visible")
      $id(`w${i}_cell2`).classList.remove("visible")
      $id(`w${i}_cell1`).classList.add("hidden")
      $id(`w${i}_cell2`).classList.add("hidden")
    }
  }
}

/* ---------------------------------------------------------------------------------------------------------------------
 * Initialise the UI and create default number of worker threads
 */
let workers_slider   = $id("workers")
let zoom_slider      = $id("zoom")
let max_iters_slider = $id("max_iters")

  workers_slider.max   = RANGE_WORKERS.MAX
  workers_slider.min   = RANGE_WORKERS.MIN
  workers_slider.value = RANGE_WORKERS.DEFAULT
  workers_slider.addEventListener("input", rebuild_workers, false)

  zoom_slider.min  = RANGE_ZOOM.MIN
  zoom_slider.max  = RANGE_ZOOM.MAX
  zoom_slider.step = RANGE_ZOOM.STEP
  zoom_slider.addEventListener("input", update_img, false)

  max_iters_slider.min  = RANGE_MAX_ITERS.MIN
  max_iters_slider.max  = RANGE_MAX_ITERS.MAX
  max_iters_slider.step = RANGE_MAX_ITERS.STEP
  max_iters_slider.addEventListener("input", update_img, false)

  $id("reset_ui_button").addEventListener("click", resetUI, false)

  resetUI({}, true)
</script>
</body>
</html>
