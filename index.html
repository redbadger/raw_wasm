<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
input[type="range"].horizontal {
  width: 400px
}
</style>
</head>
<body>
  <section id="plotArea">
    <table>
    <tr><td>Maximum iterations</td>
        <td><input class="horizontal" id="max_iters" type="range" min="100" max="10000" value="1000"></td>
        <td><span id="max_iters_txt"></span></td></tr>
    <tr><td>Zoom</td>
        <td><input class="horizontal" id="zoom" type="range" min="100" max="10000" value="200"></td>
        <td><span id="zoom_txt"></span></td></tr>
    <tr><td colspan="3" style="text-align: center;"><input id="reset_ui_button" type="button" value="Reset image"></td></tr>
    <tr><td colspan="3">Mandelbrot set calculation time <span id="mandel_exec_time"></span> ms</td></tr>
    <tr><td colspan="3">Drag to move image</td></tr>
    <tr><td colspan="3">
            <canvas id="mandelImage" style="border: 1px solid black"></canvas></td>
    <tr><td colspan="3">Julia set corresponding to coordinates (<span id="x_complex_coord"></span>,<span id="y_complex_coord"></span>) on the Mandelbrot set</td></tr>
    <tr><td colspan="3">Julia set calculated in <span id="julia_exec_time"></span>ms</td></tr>
    <tr><td colspan="3">
      <canvas id="juliaImage"  style="border: 1px solid black"></canvas></td></tr>
    </table>
  </section>
<script type="module">
// import {
//   showHostFns,
//   testWasm,
// } from "./src/js/testUtils.js"

import {
  WasmModule
} from "./src/js/wasmUtils.js"

import {
  instantiateWasmModuleSequence
} from "./src/js/wasmBrowserUtils.js"

// import { complexTestMap } from "./src/complex/tests.js"
// import { mandelTestMap }  from "./src/mandel/tests.js"
// import { colourTestMap }  from "./src/render/tests.js"

// const TEST_MODE   = false
// const SHOW_DETAIL = false

const WASM_PAGE_SIZE = 1024 * 64

const DEFAULT_CANVAS_WIDTH  = 800
const DEFAULT_CANVAS_HEIGHT = 450
const DEFAULT_PPU           = 200              // Default pixels per unit (controls zoom level)
const DEFAULT_ZOOM_STEP     = 50               // Default slider step interval
const DEFAULT_ORIGIN_STEP   = 0.01             // Step interval when Mandelbrot Set is dragged
const DEFAULT_ORIGIN_X      = -0.5             // Centre X canvas pixel in the Mandelbrot coordinate space
const DEFAULT_ORIGIN_Y      = 0                // Centre Y canvas pixel in the Mandelbort coordinate space
const DEFAULT_MAX_ITERS     = 150              // Default number of iterations for the escape time algorithm
const DEFAULT_ITERS_STEP    = 50               // Default slider step interval

const toMilliTenths = val => Math.round(val * 10000) / 10000
function $id(el) { return document.getElementById(el) }

// ---------------------------------------------------------------------------------------------------------------------
// Mouse handler functions

// Translate the mouse X or Y canvas position to the corresponding X or Y coordinate in the complex plain
const canvas_pxl_to_coord = (cnvsDim, ppu, origin) => mousePos => origin + ((mousePos - (cnvsDim / 2)) / ppu)

// Return a value clamped to the magnitude of the canvas image dimension that accountd for the canvas border width
const offset_to_clamped_pos = (offset, dim, offsetDim) => {
  let pos = offset - ((offsetDim - dim) / 2)
  return pos < 0 ? 0 : pos > dim ? dim : pos
}

// Track mouse pointer position in the Mandelbrot set
const mouse_track = evt => {
  let x_pxl = offset_to_clamped_pos(evt.offsetX, evt.target.width,  evt.target.offsetWidth)
  let y_pxl = offset_to_clamped_pos(evt.offsetY, evt.target.height, evt.target.offsetHeight)

  $id('x_complex_coord').innerHTML = window.mandel_x_pos_to_coord(x_pxl)
  $id('y_complex_coord').innerHTML = window.mandel_y_pos_to_coord(y_pxl) * -1

  if (drag_active) {
    let movement_factor = img_params.zoom.defaultValue / img_params.zoom.currentValue
    img_params.origin_x.currentValue -= evt.movementX * DEFAULT_ORIGIN_STEP * movement_factor
    img_params.origin_y.currentValue -= evt.movementY * DEFAULT_ORIGIN_STEP * movement_factor

    update_img(evt)
  } else {
    julia.origin_x = img_params.origin_x.currentValue
    julia.origin_y = img_params.origin_y.currentValue
    julia.mandel_x = x_pxl
    julia.mandel_y = y_pxl
    julia.zoom     = img_params.zoom.currentValue

    draw_fractal(julia)
  }
}

// Mouse up and down events within the Mandelbrot set
const mouse_down  = _ => drag_active = true
const mouse_up    = _ => drag_active = false

// ---------------------------------------------------------------------------------------------------------------------
function Fractal(name, canvas, context, image, imgStart, imgEnd) {
  this.name     = name
  this.canvas   = canvas
  this.context  = context
  this.image    = image
  this.imgStart = imgStart
  this.imgEnd   = imgEnd

  this.origin_x = DEFAULT_ORIGIN_X
  this.origin_y = DEFAULT_ORIGIN_Y
  this.mandel_x = 0
  this.mandel_y = 0
  this.zoom     = DEFAULT_PPU
}

// ---------------------------------------------------------------------------------------------------------------------
// Canvas definition
const mCanvas  = $id('mandelImage')
mCanvas.width  = DEFAULT_CANVAS_WIDTH
mCanvas.height = DEFAULT_CANVAS_HEIGHT

mCanvas.addEventListener('mousemove', mouse_track, false)
mCanvas.addEventListener('mousedown', mouse_down, false)
mCanvas.addEventListener('mouseup',   mouse_up, false)
mCanvas.addEventListener('mouseout',  mouse_up, false)

const mContext    = mCanvas.getContext('2d')
const mImage      = mContext.createImageData(mCanvas.width, mCanvas.height)
const mImageSize  = mCanvas.width * mCanvas.height * 4
const mImagePages = Math.ceil(mImageSize / WASM_PAGE_SIZE)
const mImageStart = 0
const mImageEnd   = mImageSize
const mandelbrot  = new Fractal("mandel", mCanvas, mContext, mImage, mImageStart, mImageEnd)

const jCanvas  = $id('juliaImage')
jCanvas.width  = DEFAULT_CANVAS_WIDTH
jCanvas.height = DEFAULT_CANVAS_HEIGHT

const jContext    = jCanvas.getContext('2d')
const jImage      = jContext.createImageData(jCanvas.width, jCanvas.height)
const jImageSize  = jCanvas.width * jCanvas.height * 4
const jImagePages = Math.ceil(jImageSize / WASM_PAGE_SIZE)
const jImageStart = mImagePages * WASM_PAGE_SIZE
const jImageEnd   = jImageStart + jImageSize
const julia       = new Fractal("julia", jCanvas, jContext, jImage, jImageStart, jImageEnd)

// ---------------------------------------------------------------------------------------------------------------------
// WASM memory allocation
// Arbitrarily allocate 4 pages for the colour palette.
// This allows for enough colours for an image to be calculated with a maximum iteration value of 32768
const palettePages = 4

const wasmMemory  = new WebAssembly.Memory({ initial : mImagePages + jImagePages + palettePages })
const wasmMemBuff = new Uint8ClampedArray(wasmMemory.buffer)

// ---------------------------------------------------------------------------------------------------------------------
// Manage image parameters
let drag_active = false

let img_params = {
  'zoom' :      { currentValue : DEFAULT_PPU,       defaultValue : DEFAULT_PPU,       hasSlider : true },
  'max_iters' : { currentValue : DEFAULT_MAX_ITERS, defaultValue : DEFAULT_MAX_ITERS, hasSlider : true },
  'origin_x' :  { currentValue : DEFAULT_ORIGIN_X,  defaultValue : DEFAULT_ORIGIN_X,  hasSlider : false },
  'origin_y' :  { currentValue : DEFAULT_ORIGIN_Y,  defaultValue : DEFAULT_ORIGIN_Y,  hasSlider : false },
}

// Mapped over img_params
const reset_img_params = sId => {
  let param_obj = img_params[sId]

  param_obj.currentValue = param_obj.defaultValue

  // Reset slider value
  if (param_obj.hasSlider) {
    $id(sId).value = param_obj.defaultValue
    $id(`${sId}_txt`).innerHTML = param_obj.defaultValue
  }

  return param_obj
}

// Mapped over img_params
const update_img_params = sId => {
  let param_obj = img_params[sId]

  // Store slider value
  if (param_obj.hasSlider) {
    param_obj.currentValue = parseInt($id(sId).value)
    $id(`${sId}_txt`).innerHTML = param_obj.currentValue
  }

  return param_obj
}

// ---------------------------------------------------------------------------------------------------------------------
const draw_fractal = f => {
  let then = window.performance.now()

  switch(f.name) {
    case "mandel":
      window.wasm.mandel_plot(
        f.canvas.width,
        f.canvas.height,
        f.origin_x,
        f.origin_y,
        f.zoom,
        img_params.max_iters.currentValue
      )
      break

    case "julia":
      window.wasm.julia_plot(
        f.canvas.width,
        f.canvas.height,
        f.origin_x,
        f.origin_y,
        f.mandel_x,
        f.mandel_y,
        f.zoom,
        img_params.max_iters.currentValue
      )

    default:
  }

  $id(`${f.name}_exec_time`).innerHTML = `${toMilliTenths(window.performance.now() - then)}`

  f.image.data.set(wasmMemBuff.slice(f.imgStart, f.imgEnd))
  f.context.putImageData(f.image,0,0)
}

// ---------------------------------------------------------------------------------------------------------------------
const update_img = evt => {
  img_params = Object
    .keys(img_params)
    .reduce((acc, sId) => { acc[sId] = update_img_params(sId); return acc }, {})

  mandelbrot.origin_x = img_params.origin_x.currentValue
  mandelbrot.origin_y = img_params.origin_y.currentValue
  mandelbrot.zoom     = img_params.zoom.currentValue

  switch(evt.target.id) {
    // Rebuild the colour palette
    case "max_iters":
      window.wasm.hsl_to_rgb(img_params.max_iters.currentValue)
      break

    // Whenever the origin moves, update the pixel to coordinate translation functions
    case "zoom":
    case "origin_x":
    case "origin_y":
    case "mandelImage":
      window.mandel_x_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.width,  img_params.zoom.currentValue, mandelbrot.origin_x)
      window.mandel_y_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.height, img_params.zoom.currentValue, mandelbrot.origin_y)
      break

    default:
  }

  draw_fractal(mandelbrot)
}

const resetUI = () => {
  window.mandel_x_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.width,  DEFAULT_PPU, DEFAULT_ORIGIN_X)
  window.mandel_y_pos_to_coord = canvas_pxl_to_coord(mandelbrot.canvas.height, DEFAULT_PPU, DEFAULT_ORIGIN_Y)

  img_params = Object.keys(img_params).reduce((acc, sId) => { acc[sId] = reset_img_params(sId); return acc }, {})

  // Generate default colour palette
  window.wasm.hsl_to_rgb(DEFAULT_MAX_ITERS)

  mandelbrot.origin_x = DEFAULT_ORIGIN_X
  mandelbrot.origin_y = DEFAULT_ORIGIN_Y
  mandelbrot.zoom     = DEFAULT_PPU

  draw_fractal(mandelbrot)
}

// ---------------------------------------------------------------------------------------------------------------------
// These WASM modules must be instantiated in the order listed below due to the fact that later modules have import
// dependencies on earlier modules
const instantiationSequence = [
  // new WasmModule('./build/complex.wasm',       'cplx'),
  new WasmModule('./build/mandel.wasm',         'mandel'),
  new WasmModule('./build/colour_palette.wasm', 'colours'),
  new WasmModule('./build/canvas.wasm',         'canvas'),
]

// Functions that either supplied to WASM by the host environment or are shared between WASM modules
const host_fns = {
  math : Math,
  js : {
    shared_mem        : wasmMemory,
    mandel_img_offset : 0,
    julia_img_offset  : WASM_PAGE_SIZE * mImagePages,
    palette_offset    : WASM_PAGE_SIZE * (mImagePages + jImagePages),
  }
}

// Create WASM property in the Window object
if (window.wasm === undefined) window.wasm = {}

instantiateWasmModuleSequence(instantiationSequence, host_fns)
  .then(wasmModules => {
    // testWasm(TEST_MODE, wasmModules.cplx.instance, complexTestMap, SHOW_DETAIL)
    // testWasm(TEST_MODE, wasmModules.mandel.instance, mandelTestMap, SHOW_DETAIL)
    // testWasm(TEST_MODE, wasmModules.canvas.instance, colourTestMap, SHOW_DETAIL)
    // showHostFns(wasmModules.hostFunctions)

    window.wasm.mandel_plot = wasmModules.canvas.instance.exports.mandel_plot
    window.wasm.julia_plot  = wasmModules.canvas.instance.exports.julia_plot
    window.wasm.hsl_to_rgb  = wasmModules.colours.instance.exports.hsl_to_rgb

    let zoom_slider = $id("zoom")
    zoom_slider.step = DEFAULT_ZOOM_STEP
    zoom_slider.addEventListener("input", update_img, false)

    let max_iters_slider = $id("max_iters")
    max_iters_slider.step = DEFAULT_ITERS_STEP
    max_iters_slider.addEventListener("input", update_img, false)

    $id("reset_ui_button").addEventListener("click", resetUI, false)

    resetUI()
  })
</script>
</body>
</html>
